C51 COMPILER V9.60.7.0   IRC_TEST                                                          09/18/2023 18:47:08 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE IRC_TEST
OBJECT MODULE PLACED IN .\Objects\IRC_Test.obj
COMPILER INVOKED BY: D:\install\Keil\C51\BIN\C51.EXE IRC_Test.c OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\IRC_Test.lst) OBJECT(.\Objects\IRC_Test.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "IRC_Test.h"
   3          
   4          typedef unsigned char u8;//基础类型定义
   5          typedef unsigned int u16;
   6          
   7          unsigned char Addr;//地址
   8          unsigned char Command;//命令
   9          unsigned char Data[4];//储存数据
  10          
  11          bit Data_Ready_Flag=0;
  12          bit Repeat_Flag=0;
  13          sbit INT0_input=P3^2;//中断入口IO定义
  14          
  15          void IRC_Init()
  16          {
  17   1              //设置外部中断
  18   1              IT0=1;//设置为下降沿触发
  19   1              EX0=1;//开启外部中断1
  20   1              EA=1;//开启总中断
  21   1              PX0=1;//优先级设置为最高
  22   1              
  23   1              TMOD &= 0xF0;                   //设置定时器模式
  24   1              TMOD |= 0x01;                   //设置定时器模式
  25   1              TL0 = 0x00;                             //设置定时初始值
  26   1              TH0 = 0x00;                             //设置定时初始值
  27   1              TF0 = 0;                                //清除TF0标志
  28   1              TR0 = 1;                                //定时器0开始计时
  29   1      }
  30          
  31          
  32          void IRC_Timer_reset()
  33          {
  34   1                      TL0 = 0x00;                     
  35   1                      TH0 = 0x00;                             
  36   1      }
  37          
  38          u16 IRC_Timer_Interval()
  39          {
  40   1              return TH0<<8|TL0;
  41   1      }
  42          
  43          unsigned char IRC_Get_Addr()
  44          {
  45   1              return Addr;
  46   1      }
  47          
  48          unsigned char IRC_Get_Command()
  49          {
  50   1              return Command;
  51   1      }
  52          
  53          bit Get_Data_Ready_Flag()
  54          {
C51 COMPILER V9.60.7.0   IRC_TEST                                                          09/18/2023 18:47:08 PAGE 2   

  55   1              if(Data_Ready_Flag){
  56   2                      Data_Ready_Flag=0;
  57   2                      return 1;
  58   2              }       
  59   1              else 
  60   1                      return 0;
  61   1      }
  62          
  63          bit Get_Repeat_Flag()
  64          {
  65   1              if(Repeat_Flag){
  66   2                      Repeat_Flag=0;
  67   2                      return 1;
  68   2              }
  69   1              else 
  70   1                      return 0;
  71   1      }
  72          
  73          void IRC_INT0_Routine() interrupt 0
  74          {       
  75   1                      u16 interval;
  76   1                      u8 i;
  77   1                      u8 j;
  78   1              
  79   1                      //关闭外部中断1，防止二次调用函数
  80   1                      EX0=0;
  81   1                      //@9ms的低电平才确定为信号的开始信号
  82   1                      IRC_Timer_reset();
  83   1                      while(INT0_input==0);   //等待前面9ms的低电平过去
  84   1                      interval=IRC_Timer_Interval();
  85   1                      if(interval>8000)//若低电平持续的时间小于8ms证明为有效信号
  86   1                      {
  87   2                                      IRC_Timer_reset();
  88   2                                      while(INT0_input==1);//高电平时间
  89   2                                      interval=IRC_Timer_Interval();
  90   2                                      if(interval>3000)
  91   2                                      {
  92   3                                                              for(i=0;i<4;i++)
  93   3                                                              {
  94   4                                                                      for(j=0;j<8;j++)
  95   4                                                                              {       
  96   5                                                                                      while(INT0_input==0);//前560us低电平
  97   5                                                                                      IRC_Timer_reset();
  98   5                                                                                      while(INT0_input==1);//高电平时间监测
  99   5                                                                                      interval=IRC_Timer_Interval();
 100   5                                                                                      Data[i]>>=1;     //i表示第几组数据
 101   5                                                                                      if(interval>=1000)                      //如果高电平出现大于1000us，那么是1
 102   5                                                                                      {
 103   6                                                                                              Data[i]|=0x80;
 104   6                                                                                      }
 105   5                                                                              }
 106   4                                                              }
 107   3                                                              while(INT0_input==0);//注意此处需要等待32bit数据发送完后多出来的低电平
 108   3                                                              if(Data[0]==~Data[1]&&Data[2]==~Data[3])
 109   3                                                              {
 110   4                                                                      Addr=Data[0];
 111   4                                                                      Command=Data[2];
 112   4                                                                      Data_Ready_Flag=1;
 113   4                                                              }
 114   3                                      }
 115   2                                      else //Repeat信号
 116   2                                      {
C51 COMPILER V9.60.7.0   IRC_TEST                                                          09/18/2023 18:47:08 PAGE 3   

 117   3                                              Repeat_Flag=1;  
 118   3                                              while(INT0_input==0);//此处repeat同样需要等待发送完后多出的低电平
 119   3                                      }
 120   2                      }
 121   1                      IE0=0;//此时外部中断1的中断标志位为1，若不手动清零，开启外部中断1后将立马
             -再次进入中断
 122   1                      EX0=1;
 123   1      }
 124          
 125          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    226    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
